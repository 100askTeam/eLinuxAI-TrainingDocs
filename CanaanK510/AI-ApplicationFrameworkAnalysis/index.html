<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-CanaanK510/AI-ApplicationFrameworkAnalysis" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.1">
<title data-rh="true">5.AI应用程序框架解析 | 东山Π</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://eai.100ask.net/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://eai.100ask.net/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://eai.100ask.net/CanaanK510/AI-ApplicationFrameworkAnalysis"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="5.AI应用程序框架解析 | 东山Π"><meta data-rh="true" name="description" content="12.1 AI应用程序数据流框图"><meta data-rh="true" property="og:description" content="12.1 AI应用程序数据流框图"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://eai.100ask.net/CanaanK510/AI-ApplicationFrameworkAnalysis"><link data-rh="true" rel="alternate" href="https://eai.100ask.net/CanaanK510/AI-ApplicationFrameworkAnalysis" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://eai.100ask.net/en/CanaanK510/AI-ApplicationFrameworkAnalysis" hreflang="en"><link data-rh="true" rel="alternate" href="https://eai.100ask.net/CanaanK510/AI-ApplicationFrameworkAnalysis" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.72113bc9.css">
<script src="/assets/js/runtime~main.5a458611.js" defer="defer"></script>
<script src="/assets/js/main.79abe73f.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="DshanPI" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="DshanPI" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">eLinux AI开发</b></a><a class="navbar__item navbar__link" href="/ELinuxAIBase/BoardIntroduction-1">嵌入式AI基础</a><a class="navbar__item navbar__link" href="/CanaanK230/Userdoc">嘉楠K230开发</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/CanaanK510/YOLOV5-ObjectDetectionAlgorithm">嘉楠K510开发</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/CanaanK510/AI-ApplicationFrameworkAnalysis" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-Hans">简体中文</a></li><li><a href="/en/CanaanK510/AI-ApplicationFrameworkAnalysis" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li></ul></div><a href="https://github.com/100askTeam/eLinuxAI-TrainingDocs" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/CanaanK510/YOLOV5-ObjectDetectionAlgorithm">1.YOLOV5目标检测算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/CanaanK510/nncase-NeuralNetworkAcceleratorConversionModel">2.nncase进行模型转换</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/CanaanK510/K510-DeploymentModel">3.K510端侧部署模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/CanaanK510/TrainACustomModelDeployment">4.训练自定义模型部署</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/CanaanK510/AI-ApplicationFrameworkAnalysis">5.AI应用程序框架解析</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/category/更多嘉楠模型部署实战">更多嘉楠模型部署实战</a><button aria-label="展开侧边栏分类 &#x27;更多嘉楠模型部署实战&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">5.AI应用程序框架解析</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>5.AI应用程序框架解析</h1>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="121-ai应用程序数据流框图">12.1 AI应用程序数据流框图<a href="#121-ai应用程序数据流框图" class="hash-link" aria-label="12.1 AI应用程序数据流框图的直接链接" title="12.1 AI应用程序数据流框图的直接链接">​</a></h3>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155117172.png" alt="image-20231012155117172" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="122-阅读端侧推理模型示例">12.2 阅读端侧推理模型示例<a href="#122-阅读端侧推理模型示例" class="hash-link" aria-label="12.2 阅读端侧推理模型示例的直接链接" title="12.2 阅读端侧推理模型示例的直接链接">​</a></h3>
<p>打开nncase开发文档网址：<a href="https://canaan-docs.100ask.net/Application/AIApplicationDevelopment-Canaan/05-nncase_Developer_Guides.html" target="_blank" rel="noopener noreferrer">https://canaan-docs.100ask.net/Application/AIApplicationDevelopment-Canaan/05-nncase_Developer_Guides.html</a></p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155157720.png" alt="image-20231012155157720" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="123-yolov5目标检测程序框架解析">12.3 YOLOV5目标检测程序框架解析<a href="#123-yolov5目标检测程序框架解析" class="hash-link" aria-label="12.3 YOLOV5目标检测程序框架解析的直接链接" title="12.3 YOLOV5目标检测程序框架解析的直接链接">​</a></h3>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155222724.png" alt="image-20231012155222724" class="img_ev3q"></p>
<p><strong>注意：</strong></p>
<p>​    1.AI工作只作画框和绘制预测类别作用。</p>
<p>​    2.显示工作只作显示屏上显示工作。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="124-yolov5目标检测程序解析-ai工作">12.4 YOLOV5目标检测程序解析-AI工作<a href="#124-yolov5目标检测程序解析-ai工作" class="hash-link" aria-label="12.4 YOLOV5目标检测程序解析-AI工作的直接链接" title="12.4 YOLOV5目标检测程序解析-AI工作的直接链接">​</a></h3>
<p><strong>1.创建类</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 创建一个目标检测类 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">objectDetect od(obj_thresh, nms_thresh, net_len, {valid_width, valid_height});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>目标检测类属于Simulator类, 用于在PC上推理kmodel</p>
<blockquote>
<p>目的：创建这个类，用于准备内存、加载模型，设置模型的输入输出、模型的推理、后处理等功能。在这个类的public中定义功能函数。</p>
</blockquote>
<p>下面为目标检测部分定义截图：</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 目标检测类定义（部分）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class objectDetect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    objectDetect(float obj_thresh, float nms_thresh, int net_len, Framesize frame_size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void prepare_memory();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void set_input(uint32_t index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void set_output();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void load_model(char *path);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void get_output();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void post_process(std::vector&lt;BoxInfo&gt; &amp;result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ~objectDetect();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>2.加载模型</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">od.load_model(kmodel_path);  // load kmodel（加载模型）</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>函数定义：</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void objectDetect::load_model(char *path)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    od_model = read_binary_file&lt;unsigned char&gt;(path); // 读取传入的地址中的模型文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interp_od.load_model({ (const gsl::byte *)od_model.data(), od_model.size() }).expect(&quot;cannot load model.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::cout &lt;&lt; &quot;============&gt; interp_od.load_model finished!&quot; &lt;&lt; std::endl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>3.准备内存</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Od.prepare_memory(); // memory allocation（准备内存）</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>截取代码prepare_memory定义中的重要片段。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">virtual_addr_output = (char *)mmap(NULL, allocAlignMemOdOutput.size, PROT_READ | PROT_WRITE, MAP_SHARED, mem_map, allocAlignMemOdOutput.phyAddr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">virtual_addr_input[i] = (char *)mmap(NULL, allocAlignMemOdInput[i].size, PROT_READ | PROT_WRITE, MAP_SHARED, mem_map, allocAlignMemOdInput[i].phyAddr);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>代码理解：内核申请一块共享内存供应用程序使用，这块内存的地址称为虚拟地址。外部应用想使用这块内存仅需要去调用这块虚拟内存即可。虚拟地址virtual_addr_input中包含了指向共享内存的指针。</p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155506083.png" alt="image-20231012155506083" class="img_ev3q"></p>
<p><strong>4.VideoCapture获得摄像头数据</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mtx.lock(); //获得锁（获得独占式资源的能力）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cv::VideoCapture capture; //使用OpenCV创建一个capture类，用于调用摄像头</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">capture.open(5);//打开/dev/video5节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// video setting</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">capture.set(cv::CAP_PROP_CONVERT_RGB, 0); //不将捕获的图像转换为RGB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">capture.set(cv::CAP_PROP_FRAME_WIDTH, net_len); //设置捕获视频宽为模型宽</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">capture.set(cv::CAP_PROP_FRAME_HEIGHT, net_len); //设置捕获视频高为模型高</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// RRRRRR....GGGGGGG....BBBBBB, CHW</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">capture.set(cv::CAP_PROP_FOURCC, V4L2_PIX_FMT_RGB24); //获取原来的格式，将原来的格式转换为RGB24图像</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mtx.unlock(); //释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cv::Mat rgb24_img_for_ai(net_len, net_len, CV_8UC3, od.virtual_addr_input[0] + (net_len - valid_width) / 2 + (net_len - valid_height) / 2 * net_len);//创建Mat数据类型，用于存储图像数据，存放位置位于虚拟地址（共享内存）中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ret = capture.read(rgb24_img_for_ai); //读取视频图像，并将图像数据存放在共享内存中</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155528834.png" alt="image-20231012155528834" class="img_ev3q"></p>
<p><strong>5.寻找3通道地址</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//padding</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uint8_t *r_addr, *g_addr, *b_addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">g_addr = (uint8_t *)od.virtual_addr_input[0] + offset_channel;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">r_addr = is_rgb ? g_addr - offset_channel : g_addr + offset_channel;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b_addr = is_rgb ? g_addr + offset_channel : g_addr - offset_channel;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>od.virtual_addr_input[0]为图像数据的首地址，那么RGB图像或BGR图像，就可知道3通道中的中间通道G的地址</p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155551482.png" alt="image-20231012155551482" class="img_ev3q"></p>
<p>知道3通道BGR中的中间通道G的地址后，求剩下两通道的地址，下面为求解rgb三通道的各个地址。</p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155603431.png" alt="image-20231012155603431" class="img_ev3q"></p>
<p><strong>6.填充图像</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//gnne_input_width：模型宽度 320 gnne_valid_width：视频输入宽度 240</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (gnne_valid_width &lt; gnne_input_width) {	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uint32_t padding_r = (gnne_input_width - gnne_valid_width); //计算总共需要填充的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uint32_t padding_l = padding_r / 2; //计算左边需要填充的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uint32_t row_offset = (gnne_input_height - gnne_valid_height) / 2; //计算下一个需要填充的偏移值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    padding_r -= padding_l; //计算右边需要填充的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int row = row_offset; row &lt; row_offset + gnne_valid_height/*30+240*/; row++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      uint32_t offset_l = row * gnne_input_width; //计算下一个左边需要填充的偏移值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      uint32_t offset_r = offset_l + gnne_valid_width + padding_l; //计算下一个右边需要填充的偏移值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      memset(r_addr + offset_l, PADDING_R, padding_l); //填充左边R通道，填充值为114（灰度值），填充范围</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      memset(g_addr + offset_l, PADDING_G, padding_l); //填充左边G通道，填充值为114（灰度值），填充范围</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      memset(b_addr + offset_l, PADDING_B, padding_l); //填充左边B通道，填充值为114（灰度值），填充范围</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      memset(r_addr + offset_r, PADDING_R, padding_r); //填充右边R通道，填充值为114（灰度值），填充范围</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      memset(g_addr + offset_r, PADDING_G, padding_r); //填充右边G通道，填充值为114（灰度值），填充范围</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      memset(b_addr + offset_r, PADDING_B, padding_r); //填充右边B通道，填充值为114（灰度值），填充范围</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155715278.png" alt="image-20231012155715278" class="img_ev3q"></p>
<p>实际图像如下所所示：</p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155732820.png" alt="image-20231012155732820" class="img_ev3q"></p>
<p><strong>7.设置输入矩阵</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">od.set_input(0); //设置输入矩阵</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Object_detect程序中set_input定义：</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void objectDetect::set_input(uint32_t index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   auto in_shape = interp_od.input_shape(0); //设置输入矩阵的shape   auto input_tensor = host_runtime_tensor::create(dt_uint8, //设置数据类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       in_shape, //设置tensor的形状</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	//设置用户态数据（存放输入数据）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       { (gsl::byte *)virtual_addr_input[index], net_len * net_len * INPUT_CHANNELS},        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	false, //是否拷贝 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       hrt::pool_shared, //内存池类型，使用的是共享内存池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       allocAlignMemOdInput[index].phyAddr).expect(“cannot create input tensor”); //共享内存的物理地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interp_od.input_tensor(0, input_tensor).expect(“cannot set input tensor”); //设置输入的矩阵</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155815092.png" alt="image-20231012155815092" class="img_ev3q"></p>
<p><strong>8.设置输出矩阵</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">od.set_output();//设置输出矩阵</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Object_detect程序中set_output定义：</p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void objectDetect::set_output()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (size_t i = 0; i &lt; interp_od.outputs_size(); i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       auto out_shape = interp_od.output_shape(i); //设置输出矩阵的shape</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       auto output_tensor = host_runtime_tensor::create(dt_float32, //设置数据类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           out_shape, //设置tensor的形状</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           {(gsl::byte *)virtualAddrOdOutput[i], output_size[i]}, //设置用户态数据（存放输出数据）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           false, //是否拷贝 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           hrt::pool_shared, output_pa_addr[i]).expect(“cannot create output tensor”); //共享内存的物理地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           interp_od.output_tensor(i, output_tensor).expect(“cannot set output tensor”); //设置输出的矩阵</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155858016.png" alt="image-20231012155858016" class="img_ev3q"></p>
<p><strong>9.运行模型推理</strong></p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">od.run(); //运行kmodel推理</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Object_detect程序中run定义：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void objectDetect::run()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interp_od.run().expect(&quot;error occurred in running model&quot;); //运行kmodel推理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012155938420.png" alt="image-20231012155938420" class="img_ev3q"></p>
<p><strong>注意：</strong></p>
<p>在运行kmodel推理前，我们已经设置了输入矩阵和输出矩阵的存放地址，所以我们只需要访问存放地址，拷贝出来使用即可。</p>
<p><strong>10.获取推理结果</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">od.get_output(); //获取推理后的输出结果</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Object_detect程序中get_output定义：</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void objectDetect::get_output()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    output_0 = reinterpret_cast&lt;float *&gt;(virtualAddrOdOutput[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    output_1 = reinterpret_cast&lt;float *&gt;(virtualAddrOdOutput[1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    output_2 = reinterpret_cast&lt;float *&gt;(virtualAddrOdOutput[2]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>提示：</strong> reinterpret_cast用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。</p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012160048382.png" alt="image-20231012160048382" class="img_ev3q"></p>
<p>**注意：**将输出矩阵拷贝到objectDetect类中的私有成员变量中</p>
<p><strong>11.后处理</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">od.post_process(result); //后处理</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Object_detect程序中get_output定义：</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void objectDetect::post_process(std::vector&lt;BoxInfo&gt; &amp;result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto boxes0 = decode_infer(output_0, net_len, 8, classes_num, frame_size, anchors_0, obj_thresh);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result.insert(result.begin(), boxes0.begin(), boxes0.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto boxes1 = decode_infer(output_1, net_len, 16, classes_num, frame_size, anchors_1, obj_thresh);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result.insert(result.begin(), boxes1.begin(), boxes1.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    auto boxes2 = decode_infer(output_2, net_len, 32, classes_num, frame_size, anchors_2, obj_thresh);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result.insert(result.begin(), boxes2.begin(), boxes2.end());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nms(result, nms_thresh);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>decode_infer函数：</p>
<p>进行后处理操作，将输出的tensor结果转换为坐标的格式存储在vector容器中。</p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012160200499.png" alt="image-20231012160200499" class="img_ev3q"></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">std::vector&lt;BoxInfo&gt; decode_infer(float *data, int net_size, int stride, int num_classes, Framesize frame_size, float anchors[][2], float threshold)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 计算比例和增益，用于缩放坐标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float ratiow = (float)net_size / frame_size.width;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float ratioh = (float)net_size / frame_size.height;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float gain = ratiow &lt; ratioh ? ratiow : ratioh;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 存储解码后的边界框</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::vector&lt;BoxInfo&gt; result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 计算网格大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int grid_size = net_size / stride;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int one_rsize = num_classes + 5;  // 每个锚框有num_classes + 5个值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 遍历网格</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int shift_y = 0; shift_y &lt; grid_size; shift_y++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int shift_x = 0; shift_x &lt; grid_size; shift_x++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int loc = shift_x + shift_y * grid_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 遍历锚框</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; 3; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float *record = data + (loc * 3 + i) * one_rsize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                float *cls_ptr = record + 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 遍历类别</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int cls = 0; cls &lt; num_classes; cls++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    float score = (cls_ptr[cls]) * (record[4]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 检查分数是否超过阈值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (score &gt; threshold)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 解码边界框坐标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cx = ((record[0]) * 2.f - 0.5f + (float)shift_x) * (float)stride;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cy = ((record[1]) * 2.f - 0.5f + (float)shift_y) * (float)stride;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        w = pow((record[2]) * 2.f, 2) * anchors[i][0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        h = pow((record[3]) * 2.f, 2) * anchors[i][1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cx -= ((net_size - frame_size.width * gain) / 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cy -= ((net_size - frame_size.height * gain) / 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cx /= gain;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cy /= gain;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        w /= gain;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        h /= gain;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 创建BoxInfo结构并将其添加到结果向量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        BoxInfo box;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        box.x1 = std::max(0, std::min(frame_size.width, int(cx - w / 2.f)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        box.y1 = std::max(0, std::min(frame_size.height, int(cy - h / 2.f)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        box.x2 = std::max(0, std::min(frame_size.width, int(cx + w / 2.f)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        box.y2 = std::max(0, std::min(frame_size.height, int(cy + h / 2.f)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        box.score = score;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        box.label = cls;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        result.push_back(box);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返回解码后的边界框向量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>nms函数：</p>
<p>删除模型预测后冗余的预测框，保留最佳的结果。</p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012160207101.png" alt="image-20231012160207101" class="img_ev3q"></p>
<p><strong>12.类别名清理</strong></p>
<div class="language-C++ language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/****fixed operation for display clear****/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/****显示屏清理的固定操作****/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cv::Mat img_argb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uint64_t index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buf_mgt_writer_get(&amp;buf_mgt, (void **)&amp;index); //获取DRM的写入数据的能力</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ScopedTiming st(&quot;display clear&quot;, enable_profile);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct drm_buffer *fbuf_argb = &amp;drm_dev.drm_bufs_argb[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    img_argb = cv::Mat(screen_height, screen_width, CV_8UC4, (uint8_t *)fbuf_argb-&gt;map); //将图像输出至map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (uint32_t cc = 0; cc &lt; points_to_clear[index].size(); cc++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cv::putText(img_argb, strs_to_clear[index][cc], points_to_clear[index][cc], cv::FONT_HERSHEY_COMPLEX, 1.5, cv::Scalar(0, 0, 0, 0), 1, 8, 0); //预测的类别名 清理为黑色</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>如下图所示：将显示屏上的类别名称清理为黑色</p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012160248794.png" alt="image-20231012160248794" class="img_ev3q"></p>
<p><strong>13.绘制矩形框</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto r : result){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (obj_cnt &lt; 32){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	struct vo_draw_frame frame; //创建画框和标注的图像</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	frame.crtc_id = drm_dev.crtc_id; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	frame.draw_en = 1; //是否绘制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	frame.frame_num = obj_cnt; //绘制个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	int x1 = r.x2 * screen_width / valid_width;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	int x0 = r.x1 * screen_width / valid_width;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	int y0 = r.y1 * screen_height / valid_height;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	int y1 = r.y2 * screen_height / valid_height;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	x1 = std::max(0, std::min(x1, (int)screen_width)); //如果x1值超出屏幕宽度，则取屏幕宽度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	x0 = std::max(0, std::min(x0, (int)screen_width)); //如果x0值超出屏幕宽度，则取屏幕宽度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	y0 = std::max(0, std::min(y0, (int)screen_height)); //如果y0值超出屏幕宽度，则取屏幕高度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	y1 = std::max(0, std::min(y1, (int)screen_height)); //如果y1值超出屏幕宽度，则取屏幕高度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	frame.line_x_start = x0; //设置x轴的起点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	frame.line_x_end = x1; //设置x轴的终点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	frame.line_y_start = y0; //设置y轴的起点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	frame.line_y_end = y1; //设置y轴的终点	draw_frame(&amp;frame); //绘制矩形框</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	cv::Point origin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	origin.x = (int)(r.x1 * screen_width / valid_width); //绘制展示标签值的x坐标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	origin.y = (int)(r.y1 * screen_height / valid_height + 10); //绘制展示标签值的y坐标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	//从result容器中获取标签值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	std::string text = od.labels[r.label] + “:” + std::to_string(round(r.score * 100) / 100.0).substr(0,4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	//在指定的坐标处绘制标签值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	cv::putText(img_argb, text, origin, cv::FONT_HERSHEY_COMPLEX, 1.5, cv::Scalar(0, 0, 255, 255), 1, 8, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	points_to_clear[index].push_back(origin); //将坐标值加入清空容器中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	strs_to_clear[index].push_back(text); //将标签值加入清空容器中</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>绘制预测框和预测类别和预测概率，并将其输出至显示屏上。</p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012160326697.png" alt="image-20231012160326697" class="img_ev3q"></p>
<p><strong>14.屏幕清理和摄像头释放</strong></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">	/****显示屏清理的操作****/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (uint32_t i = obj_cnt; i &lt; 32; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct vo_draw_frame frame;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                frame.crtc_id = drm_dev.crtc_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                frame.draw_en = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                frame.frame_num = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                draw_frame(&amp;frame);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        frame_cnt += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        buf_mgt_writer_put(&amp;buf_mgt, (void *)index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /****fixed operation for capture release and display clear****/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /****固定摄像头捕获释放和显示清除的操作****/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;%s ==========release \n&quot;, __func__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mtx.lock(); //获得锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    capture.release(); // 释放摄像头资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mtx.unlock(); //释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(uint32_t i = 0; i &lt; 32; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct vo_draw_frame frame;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        frame.crtc_id = drm_dev.crtc_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        frame.draw_en = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        frame.frame_num = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        draw_frame(&amp;frame);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012160455292.png" alt="image-20231012160455292" class="img_ev3q"></p>
<p>AI工作的流程图如下所示：</p>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012160526570.png" alt="image-20231012160526570" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="125-yolov5目标检测程序解析--display_work">12.5 YOLOV5目标检测程序解析- display_work<a href="#125-yolov5目标检测程序解析--display_work" class="hash-link" aria-label="12.5 YOLOV5目标检测程序解析- display_work的直接链接" title="12.5 YOLOV5目标检测程序解析- display_work的直接链接">​</a></h3>
<p>使用V4L2打开指定摄像头设备节点，并将调用DRM输出显示函数，将视频流buffer显示在显示屏上</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    mtx.lock(); //获得锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vdev = v4l2_open(dev_info[0].video_name[1]); //使用v4l2打开指定摄像头设备节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (vdev == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;error: unable to open video capture device %s\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dev_info[0].video_name[1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mtx.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto display_cleanup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memset(&amp;format, 0, sizeof format);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    format.pixelformat = dev_info[0].video_out_format[1] ? V4L2_PIX_FMT_NV12 : V4L2_PIX_FMT_NV16; //设置视频输出格式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    format.width = dev_info[0].video_width[1]; //设置视频宽度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    format.height = dev_info[0].video_height[1]; //设置视频高度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = v4l2_set_format(vdev, &amp;format); //设置帧格式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s:v4l2_set_format error\n&quot;,__func__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mtx.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto display_cleanup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = v4l2_alloc_buffers(vdev, V4L2_MEMORY_USERPTR, DRM_BUFFERS_COUNT); //申请帧缓冲</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s:v4l2_alloc_buffers error\n&quot;,__func__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mtx.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto display_cleanup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FD_ZERO(&amp;fds); //对内存中保存的文件句柄进行清理操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FD_SET(vdev-&gt;fd, &amp;fds); //用来将一个给定的文件描述符加入集合之中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i = 0; i &lt; vdev-&gt;nbufs; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        buffer.index = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fbuf_yuv = &amp;drm_dev.drm_bufs[buffer.index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        buffer.mem = fbuf_yuv-&gt;map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        buffer.size = fbuf_yuv-&gt;size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = v4l2_queue_buffer(vdev, &amp;buffer); //buffer入队</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;error: unable to queue buffer %u\n&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            mtx.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto display_cleanup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = v4l2_stream_on(vdev); //开启视频流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;%s error: failed to start video stream: %s (%d)\n&quot;, __func__,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            strerror(-ret), ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mtx.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto display_cleanup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mtx.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(quit.load()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct timeval timeout;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fd_set rfds;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        timeout.tv_sec = SELECT_TIMEOUT / 1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        timeout.tv_usec = (SELECT_TIMEOUT % 1000) * 1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rfds = fds;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = select(vdev-&gt;fd + 1, &amp;rfds, NULL, NULL, &amp;timeout); //定时器作用，判断是否获取视频超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (errno == EINTR)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;error: select failed with %d\n&quot;, errno);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto display_cleanup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;error: select timeout\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto display_cleanup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        process_ds0_image(vdev, format.width, format.height); //使用DRM框架将视频设备数据显示在显示屏上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">display_cleanup:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mtx.lock(); //获得锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    video_stop(vdev); //关闭视频流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    video_cleanup(vdev); //关闭内存映射相关的内存块和关闭视频设备</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mtx.unlock(); //释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="126-yolov5目标检测程序解析--drm显示函数process_ds0_image">12.6 YOLOV5目标检测程序解析- DRM显示函数process_ds0_image<a href="#126-yolov5目标检测程序解析--drm显示函数process_ds0_image" class="hash-link" aria-label="12.6 YOLOV5目标检测程序解析- DRM显示函数process_ds0_image的直接链接" title="12.6 YOLOV5目标检测程序解析- DRM显示函数process_ds0_image的直接链接">​</a></h3>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int process_ds0_image(struct v4l2_device *vdev, unsigned int width, unsigned int height)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// 声明一个结构体用于存储视频缓冲区信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	struct v4l2_video_buffer buffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 声明静态结构体，用于存储上一帧的视频缓冲区信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static struct v4l2_video_buffer old_buffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 屏幕初始化标志，用于标识屏幕是否已初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static int screen_init_flag = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mtx.lock(); //获得锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = v4l2_dequeue_buffer(vdev, &amp;buffer); //把数据放回缓存队列（出队）,并获取到视频buf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;error: unable to dequeue buffer: %s (%d)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            strerror(-ret), ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mtx.unlock(); //释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mtx.unlock(); //释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果视频缓冲区存在错误，打印警告信息并跳过当前帧的处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (buffer.error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;warning: error in dequeued buffer, skipping\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fbuf_yuv = &amp;drm_dev.drm_bufs[buffer.index]; // 获取当前帧的视频缓冲区信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果屏幕已经初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (screen_init_flag) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (drm_dev.req)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            drm_wait_vsync(); //等待显示屏空闲时间，等待完成后才可传入新数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        uint64_t index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (buf_mgt_display_get(&amp;buf_mgt, (void **)&amp;index) != 0) //获取DRM显示能力</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            index = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取用于显示的另一个缓冲区的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct drm_buffer *fbuf_argb = &amp;drm_dev.drm_bufs_argb[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //设置平面显示</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (drm_dmabuf_set_plane(fbuf_yuv, fbuf_argb)) //将视频buf传入DRM显示buf中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            std::cerr &lt;&lt; &quot;Flush fail \n&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果屏幕已经初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(screen_init_flag) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fbuf_yuv = &amp;drm_dev.drm_bufs[old_buffer.index]; // 获取上一帧的视频缓冲区信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        old_buffer.mem = fbuf_yuv-&gt;map; // 更新上一帧的视频缓冲区信息到 old_buffer 结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        old_buffer.size = fbuf_yuv-&gt;size; //获取drm显示buf的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //使用互斥锁确保线程安全性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mtx.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = v4l2_queue_buffer(vdev, &amp;old_buffer); //把数据从缓存中读取出来（入队）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printf(&quot;error: unable to requeue buffer: %s (%d)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                strerror(-ret), ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            mtx.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mtx.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        screen_init_flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">old_buffer = buffer; //将buffer的数据赋值给旧buffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img loading="lazy" src="http://photos.100ask.net/eLinuxAI-TrainingDocs/image-20231012160852281.png" alt="image-20231012160852281" class="img_ev3q"></p>
<p>注意：old_buffer是静态变量保存着上一个buffer</p>
<p>DRM显示流程为：</p>
<p>1.Buffer获取新的V4l2数据，交给DRM去做显示操作。</p>
<p>2.等待上一个buffer传输完成后，再将新buffer传入DRM去做显示。</p>
<p>3.old_buffer保存着上一个buffer的数据和地址，由于需要等待DRM读取并显示，所以等待下一回合才去入队归还buffer给驱动</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/100askTeam/eLinuxAI-TrainingDocs/tree/main/docs/CanaanK510/12-AI-ApplicationFrameworkAnalysis.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/CanaanK510/TrainACustomModelDeployment"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">4.训练自定义模型部署</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/category/更多嘉楠模型部署实战"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">更多嘉楠模型部署实战</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#121-ai应用程序数据流框图" class="table-of-contents__link toc-highlight">12.1 AI应用程序数据流框图</a></li><li><a href="#122-阅读端侧推理模型示例" class="table-of-contents__link toc-highlight">12.2 阅读端侧推理模型示例</a></li><li><a href="#123-yolov5目标检测程序框架解析" class="table-of-contents__link toc-highlight">12.3 YOLOV5目标检测程序框架解析</a></li><li><a href="#124-yolov5目标检测程序解析-ai工作" class="table-of-contents__link toc-highlight">12.4 YOLOV5目标检测程序解析-AI工作</a></li><li><a href="#125-yolov5目标检测程序解析--display_work" class="table-of-contents__link toc-highlight">12.5 YOLOV5目标检测程序解析- display_work</a></li><li><a href="#126-yolov5目标检测程序解析--drm显示函数process_ds0_image" class="table-of-contents__link toc-highlight">12.6 YOLOV5目标检测程序解析- DRM显示函数process_ds0_image</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://dongshanpi.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">DongshanPI<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://canaan-docs.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Canaan-Docs<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://renesas-docs.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Renesas-Docs<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://rtos.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">RTOS<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://tina.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">TinaSDK-Docs<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://allwinner-docs.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Allwinner-Docs<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://aw-r128.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">R128-Docs<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://space.bilibili.com/275908810" target="_blank" rel="noopener noreferrer" class="footer__link-item">BiliBili<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://forums.100ask.net" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://video.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">VideoCenter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/dongshanpi" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://weidongshan.coding.net/public/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Coding<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/100askTeam" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://gitee.com/weidongshan" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 100askTeam, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>